import re
import io
import requests
from bs4 import BeautifulSoup
from PIL import Image
from zipfile import ZipFile
from dataclasses import dataclass
from argparse import ArgumentParser
from pathlib import Path


@dataclass
class Img:
    filename: str
    url: str

    def __post_init__(self):
        if (m := re.search(r"(\d+)", self.filename)) is None:
            raise ValueError("No number in id")
        self.filename = f"{int(m.group(0)) + 1:03}.jpg"
        self.url = self.url.strip()

    def download_jpeg(self) -> bytes:
        r = requests.get(self.url, stream=True)
        image = Image.open(io.BytesIO(r.content))
        buffer = io.BytesIO()
        image.save(buffer, format="jpeg")
        return buffer.getvalue()


@dataclass
class Archive:
    filename: str
    imgs: list[Img]

    def save(self, directory: Path):
        with ZipFile(directory / self.filename, "w") as archive:
            for img in self.imgs:
                archive.writestr(img.filename, img.download_jpeg())


def find_images(url: str) -> [Img]:
    soup = BeautifulSoup(requests.get(url).text, "html.parser")
    images = soup.find_all("img")
    return [Img(image.get("id"), image.get("data-src")) for image in images]


def sequential_search(data: str, regexs: list[str]) -> str | None:
    for regex in regexs:
        if (match := re.search(regex, data)) is None:
            return None
        data = match.group(1)
    return data


def get_name(url: str, regexs: list[str], padding: int | None) -> str:
    if (name := sequential_search(url, regexs)) is None:
        raise ValueError(f"Regular Expression for name did not match for {url!r}")
    if padding:
        return f"{name:0>{padding}}.cbz"
    return name


def main():
    parser = ArgumentParser(
        prog="ComicDownloader",
        description="Given an URLs to a website with images, download and create cbz file from them.",
    )

    parser.add_argument("URLs", nargs='+', help="urls with images to download")
    parser.add_argument(
        "-u",
        "--url-name",
        nargs="?",
        default=r"^.+/([^/]+)/?$",
        help="a python regular expression with 1 capture group, that will be used to get filename for archive (default: filename in url)"
    )
    parser.add_argument(
        "-d",
        "--directory",
        nargs="?",
        default=".",
        type=Path,
        help="directory to put output file into (default: .)",
    )
    parser.add_argument(
        "-p",
        "--padding",
        nargs="?",
        const=3,
        type=int,
        help="treat filename extracted with --url-name as a number and pad it to specified length (default length: 3)"
    )
    parser.add_argument(
        "-n",
        "--number",
        action="store_true",
        help="find a number in name extracted by --url-name and use it"
    )

    args = parser.parse_args()

    if not args.directory.exists():
        args.directory.mkdir()
    if not args.directory.is_dir():
        parser.exit(status=1, message=f"{args.directory} is not a directory")

    regexs = [args.url_name]
    if args.number:
        regexs.append(r"(\d+)")

    for url in args.URLs:
        archive = Archive(get_name(url, regexs, args.padding), find_images(url))
        archive.save(args.directory)


if __name__ == "__main__":
    main()
